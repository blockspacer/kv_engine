
# Collections

This document contains some brief diagrams to help aid the understanding of
important state changes within the collection's code and the impact those
state changes have on persistence and DCP.

## Collection state change diagram

The following diagram shows a collections lifetime when stimuli occurs. The
stimuli are new JSON Collections::Manifests being applied to the
Collections::VB::Manifest.  For example a new manifest with a previously unknown
collection triggers entry into the state diagram, a manifest that now omits a
known collection would move the known collection to exclusive deleting.


Collections state changes:
```
        ●
        │┌────────────────────────┐
        ├┤ Collection is created  │
        │└────────────────────────┘
        ▼
   .─────────.
  /           \
 :  exclusive  : ◀──────────────────────────────┐
 :    open     :                                │
  \           /                                 │
    ─────────                                   │
        │                                       │┌─────────────────────────┐
        │                                       ├┤Collection (old revision)│
        │                                       ││  is completely deleted  │
        │┌────────────────────────┐             ││   (all items removed)   │
        ├┤ Collection is deleted  │             │└─────────────────────────┘
        │└────────────────────────┘             │
        ▼                                       │
  .─────────.                                  .─────────.
 /           \                                /           \
:  exclusive  : ────────────┬──────────────▶ :  open and   :
:  deleting   : ┌───────────┴─────────────┐  :  deleting   :
 \           /  │ Collection of same name │   \           /
   ─────────    │(new revision) is created│     ─────────
        │       └─────────────────────────┘
        │
        │┌───────────────────────────┐
        ├┤ Collection is completely  │
        ││deleted (all items removed)│
        │└───────────────────────────┘
        ●
```

## State diagram with SystemEvents

The same state diagram is now annotated to show the SystemEvents that are
generated by each state change.

A SystemEvent is a 'special' Item owned by the server, but queued into the
user's data stream. The SystemEvent allows the flusher and DCP to trigger
specific actions that will be ordered with the user's data stream.

```
                          ●
                          │
 ┌───────────────────────┐│
 │   CreateCollection    ├┤
 └───────────────────────┘▼
                     .─────────.
                    /           \
                   :  exclusive  : ◀──────────────────────────────┐
                   :    open     :                                │
                    \           /                                 │
                      ─────────                                   │
                          │                                       │
                          │                                       │
                          │                                       │
                          │                                       │
┌────────────────────────┐│                                       │┌─────────────────────────┐
│ BeginDeleteCollection  ├┤                                       ├┤  DeleteCollectionSoft   │
└────────────────────────┘▼          ┌───────────────────────┐    │└─────────────────────────┘
                    .─────────.      │   CreateCollection    │   .─────────.
                   /           \     └───────────┬───────────┘  /           \
                  :  exclusive  : ───────────────┴───────────▶ :  open and   :
                  :  deleting   :                              :  deleting   :
                   \           /                                \           /
                     ─────────                                    ─────────
                          │
                          │┌────────────────────────┐
                          ├┤  DeleteCollectionHard  │
                          │└────────────────────────┘
                          │
                          │
                          ●
```

## Collection States and Sequence Numbers

A collection's state is determined by the sequence numbers assigned to the
collection.

For example, when a collection is created we record the sequence number at which
we queue the create SystemEvent. And when a collection is deleted we record the
sequence number at which we queue the delete SystemEvent. This gives us a
sequence number life-time of a collection.

* Each collection has a `start_seqno` and an `end_seqno`.
* The `end_seqno` is permitted to have a special value of -6, this value means there is no end.

### Determining states from the seqno start/end:
* Exclusive Open
  * `end_seqno < start_seqno`
* Exclusive Deleting
  * `end_seqno > start_seqno`
* Open and Deleting
  * `end_seqno > 0 && end_seqno < start_seqno`

## VBucket JSON manifest

The code refers to a serialised JSON VB manifest. This is a persisted copy of
the VB::Manifest which can be used to quickly recover a VBucket's collection
state following a restart.

The VB::Manifest is also recording the sequence number of the system-events and
uses those values to track a collection's life time. A VBucket JSON manifest
looks like the following (although we don't store a formatted document).

```
{
  "separator":"::",
   "collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","revision":"1","start_seqno":"13012","end_seqno":"-6"},
    ]
}
```

### SystemEvent keys

The SystemEvents are Item's and thus have keys, they also trigger actions by the
flusher and DCP as follows, consider the life of the fruit collection which is
created at revision 1, deleted at revision 2 and created again at revision 3.

* `CreateCollection` key = `$collection::create:fruit1`
* `BeginDeleteCollection` key = `$collection::delete:fruit1`
* `DeleteCollectionSoft` key = `$collection::create:fruit1`
* `DeleteCollectionHard` key = `$collection::create:fruit1`
* The second create of `fruit` key = `$collection::create:fruit3`

### SystemEvent flushing actions

* `CreateCollection`
  * Stores a document called `$collection::create:fruit1`
  * Updates the _local/collections_manifest (A JSON copy of the VB::Manifest)
* `BeginDeleteCollection`
  * Updates the _local/collections_manifest (A JSON copy of the VB::Manifest)
* `DeleteCollectionSoft`
* Deletes a document called `$collection::create:fruit1`
  * Updates the _local/collections_manifest (A JSON copy of the VB::Manifest)
* `DeleteCollectionHard`
* Deletes a document called `$collection::create:fruit1`
  * Updates the _local/collections_manifest (A JSON copy of the VB::Manifest)

### SystemEvent DCP actions

* `CreateCollection`
  * Sends DcpSystem event message containing CreateCollection, collection="fruit" and revision="1"
* `BeginDeleteCollection`
  * Nothing
* `DeleteCollectionSoft`
  * Sends DcpSystem event message containing DeleteCollection, collection="fruit" and revision="1"
* `DeleteCollectionHard`
  * Sends DcpSystem event message containing DeleteCollection, collection="fruit" and revision="1"

## Examples

### create/delete

1. Start with `$default=exclusive open`
2. Receive (assume VB high-seqno = 200)

   `{"revision":1 "separator":"::","collections":[{"$default", "fruit"}]}`

  * `$default=exclusive open, fruit=exclusive open`
  * stored a document `$collection::create:fruit1` at seqno 201
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","revision":"1","start_seqno":"201","end_seqno":"-6"}]}
   ```
3. Receive (assume VB high-seqno = 430)

   `{"revision":2 "separator":"::","collections":[{"$default"}]}`

  * `$default=exclusive open, fruit=exclusive deleting`
  * note BeginCollectionDeletion will trigger a background scrub of the collection's items.
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","revision":"1","start_seqno":"201","end_seqno":"431"}]}

4. When the background delete of fruit is complete and assuming VB high-seqno = 561

  * `$default=exclusive open'
  * Deleted a document `$collection::create:fruit1` at seqno 562
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"}]}

### create/delete/create

1. Start with `$default=exclusive open`
2. Receive (assume VB high-seqno = 836)

   `{"revision":1 "separator":"::","collections":[{"$default", "fruit"}]}`

  * `$default=exclusive open, fruit=exclusive open`
  * stored a document `$collection::create:fruit1` at seqno 837
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","revision":"1","start_seqno":"837","end_seqno":"-6"}]}
   ```
3. Receive (assume VB high-seqno = 919)

   `{"revision":2 "separator":"::","collections":[{"$default"}]}`

  * `$default=exclusive open, fruit=exclusive deleting`
  * note BeginCollectionDeletion will trigger a background scrub of the collection's items.
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","revision":"1","start_seqno":"837","end_seqno":"920"}]}

4. Receive (before the background delete completes, VB high-seqno = 1617)

   `{"revision":3 "separator":"::","collections":[{"$default", "fruit"}]}`

  * `$default=exclusive open, fruit=open and deleting`
  * stored a document `$collection::create:fruit3` at seqno 1618
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","revision":"3","start_seqno":"1618","end_seqno":"920"}]}
   ```
5. When the background delete of fruit is complete and assuming VB high-seqno = 2010

  * `$default=exclusive open, fruit=exclusive open`
  * Deleted a document `$collection::create:fruit1` at seqno 2011
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","revision":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","revision":"3","start_seqno":"1618","end_seqno":"-6"}]}
   ```
